// Comandos Utiles de Git

git init                          : Inicializa un repositorio local en la computadora
git status                        : Revisamos el estado de la rama actual
git pull                          : Trae los cambios del repositorio remoto y hace un merge.
git add                           : A単ade los cambios a listo para commitear
git pull						  : Trae todo lo del repositorio remoto a la rama actual y hace el merge
git commit 						  : Commitea los cambios listos para commitearse
git push <nombreRemoto> <rama>    : Sube la rama al repositorio remoto
git branch						  : Muestra la lista de ramas
git checkout rama                 : Moverse entre ramas
git stash                         : Corre los cambios de la rama a un "lado" (los apila en un stack)
git stash pop                     : Trae los cambios, que estan arriba en la pila
git stash list                    : Lista de los cambios apilados en el stash
git rebase main                   : pullea lo que haya en la rama pasada (en nuestro caso la main del remoto)  a la rama actual en la que estamos trabajando
git fetch						  : Trae todo lo del repositorio remoto pero no hace el merge, queda almacenado en una rama oculta origin/main

-------------------------------------------------------------------------


// Secuencia de Trabajo (Con Merge)
git pull
git branch tarea
git checkout tarea
...trabajar...
git add .
git commit -m "tarea"
git push origin tarea 
...hacer pull request/merge request en gitlab...

// Secuencia de Trabajo (Con Stash)

Actualizar rama main local.
git pull

// Revisar las tareas libres y/o pendientes si es que hay

// Crear una nueva branch para la tarea o funcionalidad a realizar.
git branch funcionalidadRama

// Moverse a la rama
git checkout funcionalidadRama

.... trabajando ....

// Como evitar conflictos antes de hacer un merge o pr a la branch main
 
En la rama creada para realizar la tarea/funcionalidad:
---- apartar los cambios ----
git stash           

--- moverse a la rama main ---
git checkout main

-- actualizo --
git pull origin  main

-- vuelvo a mi rama en la que estaba trabajando --
git checkout funcionalidadRama

---- traer/actualizar la rama con la rama main ----
git rebase main

---- traer los cambios anteriormente apartados ----
git stash pop

... Arreglar conflictos si hay ... (si no hay mejor)

---- setear los cambios ya sin conflictos con la rama main ----
git add
git commit -m "Funcionalidad/Metodo/Clase agregada"

// Una vez terminada la funcionalidad hacer un pull request //

git push origin funcionalidadRama             

.... yendo a github a hacer el pr .....
clickear donde dice compare & pull request


/************* Comando branch *************/
git branch <rama>					- Crea una rama con el nombre pasada como parametro

git branch -d <rama>				- Borra la rama pasada como parametro del repo local, si no se le hizo el merge a la rama principal no me lo permite
git branch -D <rama>				- Borra de forma forzada la rama pasada como parametro del repo local
git branch origin --delete <rama>	- Borra la rama del repo remoto
git branch origin : <rama> 			- Borra la rama del repo remoto

git checkout <rama>					- Nos movemos a la rama pasada como parametro
git branch -m <cambiarNombre> 		- Cambia el nombre de la rama actual 


// Detalles para saber

多Que es un conlficto?
Es cuando se han hecho cambios en las mismas lineas de codigo.

多Como arreglar el conflicto?
Se debe ir al codigo lo que este por encima sera el codigo del remoto, y lo que este por debajo de
sera el codigo que nosotros agregamos.
Borrar los , y fijandose en que cosas nos conviene dejar o que cosas ya estan desactualizadas.
Hacer el pr luego de esto.

多Como evitar un conflicto?
Cuando nos referimos a evitar un conflicto, queremos decir evitar que se suba a la rama main. Por lo general los commits 
de la rama main deben ser solo actualizaciones. Por ende el conflicto debe ser arreglado antes de subirse a main. Para ello
usamos git rebase.
  git rebase main, trae los cambios (si es que hay) de la rama main a la actual. Esto por si justo alguien hizo un commit en la
  rama main, mientras nosotros seguimos desarrollando en nuestra rama.
  Pero no dejara traerlos si hay archivos no commiteados en nuestra rama, para evitar commitear demas se usa git stash.
  git stash, almacena los cambios no commiteados en un stack, limpiando asi la rama, lo que permite hacer git rebase main.
  Una vez traidos los cambios de la rama main, con git stash pop devolvemos nuestros cambios a donde estaban antes. Esto hara
un merge con lo que haya en la rama, asi si hay conflictos con nuestros cambios y la version de la rama main, seran arreglados
en nuestra rama, y no en la main. Luego se procede a hacer el pr o seguir con el desarrollo en esa rama.
